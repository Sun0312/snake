#include "Map.h"
#include "Board.h"
#include <fstream>
#include <string>
#include <vector>
#include <ncurses.h>
using namespace std;

Map::Map(int width, int height, int br, int bc) : Board(width, height, br, bc), currentMapIndex(0) {
    initializeMaps(); // 맵 데이터 초기화
}
Map::Map(Map& copy) : Board(copy.win) {

}

void Map::initializeMaps() {
    // 첫 번째 맵 데이터
    maps.push_back({
        {'2', '1', '1', '1', '1', '1', '1', '1', '1', '2'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'2', '1', '1', '1', '1', '1', '1', '1', '1', '2'}
    });

    // 두 번째 맵 데이터
    maps.push_back({
        {'2', '1', '1', '1', '1', '1', '1', '1', '1', '2'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '1', '1', '1', '1', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'2', '1', '1', '1', '1', '1', '1', '1', '1', '2'}
    });

    // 세 번째 맵 데이터
    maps.push_back({
        {'2', '1', '1', '1', '1', '1', '1', '1', '1', '2'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '1', '1', '1', '1', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'1', '0', '0', '1', '1', '1', '1', '0', '0', '1'},
        {'1', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'2', '1', '1', '1', '1', '1', '1', '1', '1', '2'}
    });
}

void Map::nextMap() {
    if (currentMapIndex + 1 < maps.size()) {
        currentMapIndex++;
    }
}

int Map::getCMI(){return currentMapIndex;}
int Map::getCMI()const{return currentMapIndex;}

vector<vector<char>>* Map::getGrid(){
    return &(maps[currentMapIndex]);
}
vector<vector<char>> Map::getGrid()const{
    return (maps[currentMapIndex]);
}